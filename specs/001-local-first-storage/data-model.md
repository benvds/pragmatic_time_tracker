# Data Model: Local-First Storage System

**Feature**: Local-First Storage System  
**Date**: 2025-10-12  
**Status**: Complete

## Overview

This document defines the data model for the local-first storage system using LiveStore's event-sourced architecture. The model consists of events (immutable change log), tables (current state), and materializers (event-to-state mappings).

## Event-Sourced Architecture

LiveStore uses an event-sourced design where:
1. **Events** represent immutable facts about what happened
2. **Tables** store the current derived state
3. **Materializers** define how events update state

This provides:
- Complete audit trail of all changes
- Replayable history
- Time-travel debugging capabilities
- Simplified sync (future feature)

## Events

Events are the source of truth. All data changes flow through events.

### v1.EntryCreated

**Purpose**: Record creation of a new time tracking entry

**Schema**:
```typescript
{
  id: string              // UUID v4 generated by client
  date: Date              // Date of the time entry
  minutes: number         // Duration in minutes (positive integer)
  description: string     // Text description of work performed
}
```

**Business Rules**:
- `id` must be unique across all entries
- `date` must be valid date (not future date beyond current day)
- `minutes` must be positive integer (1-1440 for 1 minute to 24 hours)
- `description` can be empty string but not null

**Example**:
```typescript
{
  id: "550e8400-e29b-41d4-a716-446655440000",
  date: new Date("2025-10-12T09:30:00"),
  minutes: 120,
  description: "Development work on storage feature"
}
```

### v1.EntryUpdated

**Purpose**: Record modification of an existing time entry

**Schema**:
```typescript
{
  id: string              // UUID of entry to update (required)
  date?: Date             // New date (optional)
  minutes?: number        // New duration (optional)
  description?: string    // New description (optional)
}
```

**Business Rules**:
- `id` must reference existing entry
- At least one optional field must be provided
- Optional fields follow same validation as EntryCreated
- Can update one or multiple fields in single event
- Cannot update deleted entries (deletedAt !== null)

**Example**:
```typescript
{
  id: "550e8400-e29b-41d4-a716-446655440000",
  minutes: 150,
  description: "Development work on storage feature (updated)"
}
```

### v1.EntryDeleted

**Purpose**: Record soft deletion of a time entry

**Schema**:
```typescript
{
  id: string              // UUID of entry to delete (required)
  deletedAt: Date         // Timestamp of deletion
}
```

**Business Rules**:
- `id` must reference existing entry
- `deletedAt` must be valid date (typically current time)
- Soft delete preserves entry in database with deletedAt flag
- Deleted entries excluded from normal queries
- Cannot delete already-deleted entry

**Example**:
```typescript
{
  id: "550e8400-e29b-41d4-a716-446655440000",
  deletedAt: new Date("2025-10-12T14:30:00")
}
```

**Design Note**: Soft deletes are used instead of hard deletes to:
- Maintain audit trail
- Enable undo functionality (future)
- Preserve data integrity
- Support sync conflict resolution (future)

## Tables

Tables represent the current materialized state derived from events.

### entries

**Purpose**: Store current state of all time tracking entries

**Schema**:
```typescript
{
  id: string              // Primary key, UUID
  date: integer           // SQLite integer (Date as milliseconds since epoch)
  minutes: integer        // Duration in minutes
  description: text       // Text description
  deletedAt: integer?     // SQLite integer (nullable), deletion timestamp
}
```

**Column Details**:

| Column | Type | Constraints | Schema Transform | Notes |
|--------|------|-------------|------------------|-------|
| `id` | text | PRIMARY KEY | - | UUID v4 format |
| `date` | integer | NOT NULL | DateFromNumber | Stored as Unix timestamp in milliseconds |
| `minutes` | integer | NOT NULL | - | Positive integer, 1-1440 range |
| `description` | text | NOT NULL | - | Can be empty string |
| `deletedAt` | integer | NULL | DateFromNumber | NULL for active entries, timestamp for deleted |

**Indexes**:
- Primary key on `id` (automatic)
- Index on `date` (for chronological queries) - added during implementation
- Index on `deletedAt` (for filtering active entries) - added during implementation

**Query Patterns**:

1. **Get all active entries**:
   ```typescript
   tables.entries.where({ deletedAt: null })
   ```

2. **Get entries by date range**:
   ```typescript
   tables.entries
     .where({ deletedAt: null })
     .where('date', '>=', startDate)
     .where('date', '<=', endDate)
   ```

3. **Get entries ordered chronologically**:
   ```typescript
   tables.entries
     .where({ deletedAt: null })
     .orderBy('date', 'desc')
   ```

4. **Search entries by description**:
   ```typescript
   tables.entries
     .where({ deletedAt: null })
     .where('description', 'like', `%${searchTerm}%`)
   ```

## Materializers

Materializers define how events update table state. They are pure functions that return SQL operations.

### v1.EntryCreated → entries.insert

**Operation**: Insert new row into entries table

**Logic**:
```typescript
({ id, date, minutes, description }) =>
  tables.entries.insert({
    id,
    date,
    minutes,
    description,
    deletedAt: null  // Initialize as active entry
  })
```

**Idempotency**: Insert with same id will fail (primary key constraint). Events should be unique by design.

### v1.EntryUpdated → entries.update

**Operation**: Update existing row in entries table

**Logic**:
```typescript
({ id, date, minutes, description }) =>
  tables.entries.update({
    ...(date !== undefined && { date }),
    ...(minutes !== undefined && { minutes }),
    ...(description !== undefined && { description }),
  }).where({ id })
```

**Idempotency**: Multiple updates with same values are idempotent (no-op if values unchanged).

**Notes**:
- Only updates fields present in event
- `where({ id })` ensures update targets correct entry
- No-op if id doesn't exist

### v1.EntryDeleted → entries.update

**Operation**: Soft delete by setting deletedAt timestamp

**Logic**:
```typescript
({ id, deletedAt }) =>
  tables.entries.update({ deletedAt }).where({ id })
```

**Idempotency**: Setting deletedAt to same timestamp is idempotent.

**Design Decision**: Soft delete uses UPDATE instead of DELETE to preserve data.

## Data Types and Validation

### Type Mappings

| Logical Type | Event Schema | SQLite Type | Transform |
|-------------|--------------|-------------|-----------|
| UUID string | Schema.String | text | - |
| Date | Schema.DateFromNumber | integer | Date ↔ milliseconds |
| Duration (minutes) | Schema.Number | integer | - |
| Description | Schema.String | text | - |
| Optional Date | Schema.DateFromNumber.pipe(Schema.optional) | integer (nullable) | Date ↔ milliseconds |

### Validation Rules

**At Event Level** (enforced by Schema):
- Type validation (string, number, Date)
- Required vs optional fields
- Structure validation (no extra fields)

**At Application Level** (enforced before committing events):
- `id`: Valid UUID v4 format
- `date`: Not in future (beyond current day), valid Date object
- `minutes`: Integer between 1 and 1440
- `description`: String (can be empty), max length 10,000 characters
- `id` for updates/deletes: References existing entry
- Updates: At least one field provided
- Deletes: Entry not already deleted

**At Database Level** (enforced by SQLite constraints):
- Primary key uniqueness
- NOT NULL constraints
- Integer type constraints

### Edge Cases

| Case | Handling |
|------|----------|
| Empty description | Allowed (empty string) |
| 0 or negative minutes | Rejected at validation (min: 1) |
| >1440 minutes | Allowed (multi-day entry) but warning in UI |
| Future date | Rejected at validation (max: today) |
| Duplicate id | Rejected by database (PK constraint) |
| Update non-existent entry | Silent no-op in materializer |
| Delete already-deleted entry | Overwrites deletedAt timestamp |
| Concurrent updates (multi-tab) | Last write wins (event ordering) |

## Seed Data

Seed data is represented as arrays of events.

### Development Seed Data

**Purpose**: Realistic sample data for development

**Characteristics**:
- 10-20 entries spanning last 7 days
- Varied durations (30 min to 8 hours)
- Realistic descriptions
- Includes some multi-day tracking
- No deleted entries

**Example**:
```typescript
export const developmentSeedData = [
  events.entryCreated({
    id: 'dev-1',
    date: new Date('2025-10-05T09:00:00'),
    minutes: 120,
    description: 'Morning standup and planning',
  }),
  events.entryCreated({
    id: 'dev-2',
    date: new Date('2025-10-05T13:00:00'),
    minutes: 240,
    description: 'Feature development - user authentication',
  }),
  // ... more entries
]
```

### Test Seed Data

**Purpose**: Edge cases and boundary conditions for testing

**Characteristics**:
- Minimal entries (5-10)
- Edge cases: empty description, min/max durations
- Boundary dates: start/end of day, month, year
- Includes deleted entries
- Predictable IDs for test assertions

**Example**:
```typescript
export const testSeedData = [
  events.entryCreated({
    id: 'test-edge-1',
    date: new Date('2025-01-01T00:00:00'),
    minutes: 1,
    description: '',
  }),
  events.entryCreated({
    id: 'test-edge-2',
    date: new Date('2025-12-31T23:59:59'),
    minutes: 1440,
    description: 'X'.repeat(10000), // Max length
  }),
  events.entryCreated({
    id: 'test-deleted-1',
    date: new Date('2025-10-10T12:00:00'),
    minutes: 60,
    description: 'To be deleted',
  }),
  events.entryDeleted({
    id: 'test-deleted-1',
    deletedAt: new Date('2025-10-11T12:00:00'),
  }),
]
```

## Data Migration Strategy

**Current Version**: v1 (initial version)

**Future Migrations**:
When schema changes are needed:
1. Create new event versions (e.g., v2.EntryCreated)
2. Add new materializers for v2 events
3. Keep v1 materializers for historical events
4. Migration script replays events with new materializers
5. Old events remain in log, new state reflects v2 schema

**Example Future Migration** (hypothetical):
```typescript
// v2: Add tags field
events.entryCreated = Events.synced({
  name: 'v2.EntryCreated',
  schema: Schema.Struct({
    id: Schema.String,
    date: Schema.DateFromNumber,
    minutes: Schema.Number,
    description: Schema.String,
    tags: Schema.Array(Schema.String), // NEW FIELD
  }),
})

// Migration materializer handles v1 events for v2 schema
materializers['v1.EntryCreated'] = ({ id, date, minutes, description }) =>
  tables.entries.insert({
    id, date, minutes, description,
    tags: [],  // Default for v1 events
  })
```

## Schema Version

**Version**: 1.0.0  
**Last Updated**: 2025-10-12  
**Breaking Changes**: None (initial version)

## Appendix: Full TypeScript Schema

```typescript
// src/features/storage/schema.ts
import { Events, makeSchema, Schema, State } from '@livestore/livestore'

// Events
export const events = {
  entryCreated: Events.synced({
    name: 'v1.EntryCreated',
    schema: Schema.Struct({
      id: Schema.String,
      date: Schema.DateFromNumber,
      minutes: Schema.Number,
      description: Schema.String,
    }),
  }),
  entryUpdated: Events.synced({
    name: 'v1.EntryUpdated',
    schema: Schema.Struct({
      id: Schema.String,
      date: Schema.DateFromNumber.pipe(Schema.optional),
      minutes: Schema.Number.pipe(Schema.optional),
      description: Schema.String.pipe(Schema.optional),
    }),
  }),
  entryDeleted: Events.synced({
    name: 'v1.EntryDeleted',
    schema: Schema.Struct({
      id: Schema.String,
      deletedAt: Schema.DateFromNumber,
    }),
  }),
}

// Tables
export const tables = {
  entries: State.SQLite.table({
    name: 'entries',
    columns: {
      id: State.SQLite.text({ primaryKey: true }),
      date: State.SQLite.integer({ 
        schema: Schema.DateFromNumber 
      }),
      minutes: State.SQLite.integer(),
      description: State.SQLite.text(),
      deletedAt: State.SQLite.integer({ 
        nullable: true,
        schema: Schema.DateFromNumber 
      }),
    },
  }),
}

// Materializers
const materializers = State.SQLite.materializers(events, {
  'v1.EntryCreated': ({ id, date, minutes, description }) =>
    tables.entries.insert({ 
      id, 
      date, 
      minutes, 
      description,
      deletedAt: null,
    }),
  'v1.EntryUpdated': ({ id, date, minutes, description }) =>
    tables.entries.update({
      ...(date !== undefined && { date }),
      ...(minutes !== undefined && { minutes }),
      ...(description !== undefined && { description }),
    }).where({ id }),
  'v1.EntryDeleted': ({ id, deletedAt }) =>
    tables.entries.update({ deletedAt }).where({ id }),
})

// Schema
const state = State.SQLite.makeState({ tables, materializers })
export const schema = makeSchema({ events, state })
export type Schema = typeof schema
```
